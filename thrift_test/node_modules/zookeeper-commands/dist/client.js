"use strict";
var zookeeper = require('node-zookeeper-client');
function create(zookeeper_connect_string, zk_node_path, zk_node_data, create_mode) {
    if (!create_mode) {
        create_mode = zookeeper.CreateMode.PERSISTENT;
    }
    return new Promise(function (resolve, reject) {
        var client = zookeeper.createClient(zookeeper_connect_string);
        client.once('connected', function () {
            client.create(zk_node_path, new Buffer(zk_node_data), create_mode, function (error) {
                client.close();
                if (error) {
                    reject(error);
                }
                else {
                    resolve(zk_node_path);
                }
            });
        });
        client.connect();
    });
}
exports.create = create;
;
function mkdirp(zookeeper_connect_string, zk_node_path, zk_node_data, create_mode) {
    if (!create_mode) {
        create_mode = zookeeper.CreateMode.PERSISTENT;
    }
    var data = zk_node_data ? new Buffer(zk_node_data) : null;
    return new Promise(function (resolve, reject) {
        var client = zookeeper.createClient(zookeeper_connect_string);
        client.once('connected', function () {
            client.mkdirp(zk_node_path, data, create_mode, function (error, path) {
                client.close();
                if (error) {
                    reject(error);
                }
                else {
                    resolve(zk_node_path);
                }
            });
        });
        client.connect();
    });
}
exports.mkdirp = mkdirp;
;
function exists(zookeeper_connect_string, zk_node_path) {
    return new Promise(function (resolve, reject) {
        var client = zookeeper.createClient(zookeeper_connect_string);
        client.once('connected', function () {
            client.exists(zk_node_path, function (error, stat) {
                client.close();
                if (error) {
                    reject(error);
                }
                else {
                    if (stat) {
                        resolve(true);
                    }
                    else {
                        resolve(false);
                    }
                }
            });
        });
        client.connect();
    });
}
exports.exists = exists;
;
function getData(zookeeper_connect_string, zk_node_path) {
    return new Promise(function (resolve, reject) {
        var client = zookeeper.createClient(zookeeper_connect_string);
        client.once('connected', function () {
            client.getData(zk_node_path, function (error, data, stat) {
                client.close();
                if (error) {
                    reject(error);
                    return;
                }
                var result = data.toString('utf8');
                resolve(result);
            });
        });
        client.connect();
    });
}
exports.getData = getData;
;
function setData(zookeeper_connect_string, zk_node_path, zk_node_data) {
    var data = zk_node_data ? new Buffer(zk_node_data) : null;
    return new Promise(function (resolve, reject) {
        var client = zookeeper.createClient(zookeeper_connect_string);
        client.once('connected', function () {
            client.setData(zk_node_path, data, function (error, stat) {
                client.close();
                if (error) {
                    console.log('Failed setData node: %s due to: %s.', zk_node_path, error);
                    reject(error);
                    return;
                }
                console.log('Data is set');
                resolve(true);
            });
        });
        client.connect();
    });
}
exports.setData = setData;
;
function remove(zookeeper_connect_string, zk_node_path) {
    return new Promise(function (resolve, reject) {
        var client = zookeeper.createClient(zookeeper_connect_string);
        client.once('connected', function () {
            client.remove(zk_node_path, function (error) {
                client.close();
                if (error) {
                    reject(error);
                    return;
                }
                resolve(true);
            });
        });
        client.connect();
    });
}
exports.remove = remove;
;
//# sourceMappingURL=client.js.map